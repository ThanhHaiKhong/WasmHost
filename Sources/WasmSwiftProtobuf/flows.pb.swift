// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: flows.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct AsyncifyOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var premium: Bool = false

  public var contentType: String = String()

  public var bundleID: String = String()

  public var deviceID: String = String()

  public var countryCode: String = String()

  public var languageCode: String = String()

  public var regionCode: String = String()

  /// app version
  public var appVersion: String = String()

  /// extra arguments
  /// api_key embedded in sdk
  public var extra: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _extra ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_extra = newValue}
  }
  /// Returns true if `extra` has been explicitly set.
  public var hasExtra: Bool {return self._extra != nil}
  /// Clears the value of `extra`. Subsequent reads from it will return its default value.
  public mutating func clearExtra() {self._extra = nil}

  public var platform: String = String()

  /// user id
  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _extra: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct AsyncifyCookie: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  public var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  public mutating func clearDomain() {self._domain = nil}

  public var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var name: String = String()

  public var value: String = String()

  public var secure: String {
    get {return _secure ?? String()}
    set {_secure = newValue}
  }
  /// Returns true if `secure` has been explicitly set.
  public var hasSecure: Bool {return self._secure != nil}
  /// Clears the value of `secure`. Subsequent reads from it will return its default value.
  public mutating func clearSecure() {self._secure = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _domain: String? = nil
  fileprivate var _path: String? = nil
  fileprivate var _secure: String? = nil
}

public struct AsyncifyAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var action: AsyncifyAction.OneOf_Action? = nil

  public var http: AsyncifyAction.HTTP {
    get {
      if case .http(let v)? = action {return v}
      return AsyncifyAction.HTTP()
    }
    set {action = .http(newValue)}
  }

  public var ws: AsyncifyAction.WebSocket {
    get {
      if case .ws(let v)? = action {return v}
      return AsyncifyAction.WebSocket()
    }
    set {action = .ws(newValue)}
  }

  public var regex: AsyncifyAction.Regex {
    get {
      if case .regex(let v)? = action {return v}
      return AsyncifyAction.Regex()
    }
    set {action = .regex(newValue)}
  }

  public var js: AsyncifyAction.JavaScript {
    get {
      if case .js(let v)? = action {return v}
      return AsyncifyAction.JavaScript()
    }
    set {action = .js(newValue)}
  }

  public var fd: AsyncifyAction.FileDescriptor {
    get {
      if case .fd(let v)? = action {return v}
      return AsyncifyAction.FileDescriptor()
    }
    set {action = .fd(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable, Sendable {
    case http(AsyncifyAction.HTTP)
    case ws(AsyncifyAction.WebSocket)
    case regex(AsyncifyAction.Regex)
    case js(AsyncifyAction.JavaScript)
    case fd(AsyncifyAction.FileDescriptor)

  }

  //// All of reponse need send back to wasm guest by `Sync` command
  public struct HTTP: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var headers: Dictionary<String,String> = [:]

    public var method: String = String()

    public var body: TypesBytes {
      get {return _body ?? TypesBytes()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    public var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    public mutating func clearBody() {self._body = nil}

    public var cookies: [AsyncifyCookie] = []

    /// key field is form name, value is form value
    public var multiparts: [AsyncifyAction.HTTP.Part] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Part: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var field: String = String()

      public var value: String = String()

      public var filename: String {
        get {return _filename ?? String()}
        set {_filename = newValue}
      }
      /// Returns true if `filename` has been explicitly set.
      public var hasFilename: Bool {return self._filename != nil}
      /// Clears the value of `filename`. Subsequent reads from it will return its default value.
      public mutating func clearFilename() {self._filename = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _filename: String? = nil
    }

    public init() {}

    fileprivate var _body: TypesBytes? = nil
  }

  public struct WebSocket: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var headers: Dictionary<String,String> = [:]

    public var body: TypesBytes {
      get {return _body ?? TypesBytes()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    public var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    public mutating func clearBody() {self._body = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _body: TypesBytes? = nil
  }

  public struct Regex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var input: TypesString {
      get {return _input ?? TypesString()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {return self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {self._input = nil}

    public var pattern: String = String()

    public var groups: [Int32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _input: TypesString? = nil
  }

  public struct JavaScript: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// function source
    public var src: String = String()

    public var action: AsyncifyAction.JavaScript.OneOf_Action? = nil

    public var eval: AsyncifyAction.JavaScript.Eval {
      get {
        if case .eval(let v)? = action {return v}
        return AsyncifyAction.JavaScript.Eval()
      }
      set {action = .eval(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Action: Equatable, Sendable {
      case eval(AsyncifyAction.JavaScript.Eval)

    }

    public struct Eval: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// function name
      public var fn: String = String()

      /// function arguments
      public var args: [AsyncifyFieldEntry] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct FileDescriptor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var action: AsyncifyAction.FileDescriptor.OneOf_Action? = nil

    public var write: AsyncifyAction.FileDescriptor.Write {
      get {
        if case .write(let v)? = action {return v}
        return AsyncifyAction.FileDescriptor.Write()
      }
      set {action = .write(newValue)}
    }

    public var read: AsyncifyAction.FileDescriptor.Read {
      get {
        if case .read(let v)? = action {return v}
        return AsyncifyAction.FileDescriptor.Read()
      }
      set {action = .read(newValue)}
    }

    public var metadata: AsyncifyAction.FileDescriptor.Metadata {
      get {
        if case .metadata(let v)? = action {return v}
        return AsyncifyAction.FileDescriptor.Metadata()
      }
      set {action = .metadata(newValue)}
    }

    public var delete: AsyncifyAction.FileDescriptor.Delete {
      get {
        if case .delete(let v)? = action {return v}
        return AsyncifyAction.FileDescriptor.Delete()
      }
      set {action = .delete(newValue)}
    }

    public var mkdir: AsyncifyAction.FileDescriptor.Mkdir {
      get {
        if case .mkdir(let v)? = action {return v}
        return AsyncifyAction.FileDescriptor.Mkdir()
      }
      set {action = .mkdir(newValue)}
    }

    public var move: AsyncifyAction.FileDescriptor.Move {
      get {
        if case .move(let v)? = action {return v}
        return AsyncifyAction.FileDescriptor.Move()
      }
      set {action = .move(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Action: Equatable, Sendable {
      case write(AsyncifyAction.FileDescriptor.Write)
      case read(AsyncifyAction.FileDescriptor.Read)
      case metadata(AsyncifyAction.FileDescriptor.Metadata)
      case delete(AsyncifyAction.FileDescriptor.Delete)
      case mkdir(AsyncifyAction.FileDescriptor.Mkdir)
      case move(AsyncifyAction.FileDescriptor.Move)

    }

    public struct Write: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var data: TypesBytes {
        get {return _data ?? TypesBytes()}
        set {_data = newValue}
      }
      /// Returns true if `data` has been explicitly set.
      public var hasData: Bool {return self._data != nil}
      /// Clears the value of `data`. Subsequent reads from it will return its default value.
      public mutating func clearData() {self._data = nil}

      /// base64, ...
      public var enc: String {
        get {return _enc ?? String()}
        set {_enc = newValue}
      }
      /// Returns true if `enc` has been explicitly set.
      public var hasEnc: Bool {return self._enc != nil}
      /// Clears the value of `enc`. Subsequent reads from it will return its default value.
      public mutating func clearEnc() {self._enc = nil}

      /// append mode
      public var append: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _data: TypesBytes? = nil
      fileprivate var _enc: String? = nil
    }

    public struct Read: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var enc: String {
        get {return _enc ?? String()}
        set {_enc = newValue}
      }
      /// Returns true if `enc` has been explicitly set.
      public var hasEnc: Bool {return self._enc != nil}
      /// Clears the value of `enc`. Subsequent reads from it will return its default value.
      public mutating func clearEnc() {self._enc = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _enc: String? = nil
    }

    public struct Metadata: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Delete: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Mkdir: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Move: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var to: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

public struct AsyncifyFieldEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: AsyncifyFieldEntry.TypeEnum = .unspecified

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case bool // = 1
    case int // = 2
    case double // = 3
    case string // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bool
      case 2: self = .int
      case 3: self = .double
      case 4: self = .string
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bool: return 1
      case .int: return 2
      case .double: return 3
      case .string: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [AsyncifyFieldEntry.TypeEnum] = [
      .unspecified,
      .bool,
      .int,
      .double,
      .string,
    ]

  }

  public init() {}
}

/// Host
/// - send `call` command to Guest
/// Guest
/// - send `delegate` action to Host
/// - Host do action then response `sync` command
public struct AsyncifyCommand: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: AsyncifyOptions {
    get {return _storage._options ?? AsyncifyOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {_uniqueStorage()._options = nil}

  public var kind: AsyncifyCommand.Kind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  public var call: AsyncifyCommand.Call {
    get {
      if case .call(let v)? = _storage._data {return v}
      return AsyncifyCommand.Call()
    }
    set {_uniqueStorage()._data = .call(newValue)}
  }

  public var sync: AsyncifyCommand.Sync {
    get {
      if case .sync(let v)? = _storage._data {return v}
      return AsyncifyCommand.Sync()
    }
    set {_uniqueStorage()._data = .sync(newValue)}
  }

  public var event: AsyncifyCommand.Event {
    get {
      if case .event(let v)? = _storage._data {return v}
      return AsyncifyCommand.Event()
    }
    set {_uniqueStorage()._data = .event(newValue)}
  }

  public var delegate: AsyncifyAction {
    get {
      if case .delegate(let v)? = _storage._data {return v}
      return AsyncifyAction()
    }
    set {_uniqueStorage()._data = .delegate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case call(AsyncifyCommand.Call)
    case sync(AsyncifyCommand.Sync)
    case event(AsyncifyCommand.Event)
    case delegate(AsyncifyAction)

  }

  public enum Kind: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case call // = 0
    case sync // = 1
    case event // = 2
    case delegate // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .call
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .call
      case 1: self = .sync
      case 2: self = .event
      case 3: self = .delegate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .call: return 0
      case .sync: return 1
      case .event: return 2
      case .delegate: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [AsyncifyCommand.Kind] = [
      .call,
      .sync,
      .event,
      .delegate,
    ]

  }

  public struct Call: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var args: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _args ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_args = newValue}
    }
    /// Returns true if `args` has been explicitly set.
    public var hasArgs: Bool {return self._args != nil}
    /// Clears the value of `args`. Subsequent reads from it will return its default value.
    public mutating func clearArgs() {self._args = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _args: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public struct Sync: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var action: AsyncifyCommand.Sync.OneOf_Action? = nil

    public var http: AsyncifyCommand.Sync.HTTP {
      get {
        if case .http(let v)? = action {return v}
        return AsyncifyCommand.Sync.HTTP()
      }
      set {action = .http(newValue)}
    }

    public var ws: AsyncifyCommand.Sync.WebSocket {
      get {
        if case .ws(let v)? = action {return v}
        return AsyncifyCommand.Sync.WebSocket()
      }
      set {action = .ws(newValue)}
    }

    public var regex: AsyncifyCommand.Sync.Regex {
      get {
        if case .regex(let v)? = action {return v}
        return AsyncifyCommand.Sync.Regex()
      }
      set {action = .regex(newValue)}
    }

    public var js: AsyncifyCommand.Sync.JavaScript {
      get {
        if case .js(let v)? = action {return v}
        return AsyncifyCommand.Sync.JavaScript()
      }
      set {action = .js(newValue)}
    }

    public var fd: AsyncifyCommand.Sync.FileDescriptor {
      get {
        if case .fd(let v)? = action {return v}
        return AsyncifyCommand.Sync.FileDescriptor()
      }
      set {action = .fd(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Action: Equatable, Sendable {
      case http(AsyncifyCommand.Sync.HTTP)
      case ws(AsyncifyCommand.Sync.WebSocket)
      case regex(AsyncifyCommand.Sync.Regex)
      case js(AsyncifyCommand.Sync.JavaScript)
      case fd(AsyncifyCommand.Sync.FileDescriptor)

    }

    public struct HTTP: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var body: TypesBytes {
        get {return _body ?? TypesBytes()}
        set {_body = newValue}
      }
      /// Returns true if `body` has been explicitly set.
      public var hasBody: Bool {return self._body != nil}
      /// Clears the value of `body`. Subsequent reads from it will return its default value.
      public mutating func clearBody() {self._body = nil}

      public var headers: Dictionary<String,String> = [:]

      public var cookies: [AsyncifyCookie] = []

      public var code: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _body: TypesBytes? = nil
    }

    public struct WebSocket: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var body: TypesBytes {
        get {return _body ?? TypesBytes()}
        set {_body = newValue}
      }
      /// Returns true if `body` has been explicitly set.
      public var hasBody: Bool {return self._body != nil}
      /// Clears the value of `body`. Subsequent reads from it will return its default value.
      public mutating func clearBody() {self._body = nil}

      public var headers: Dictionary<String,String> = [:]

      public var cookies: [AsyncifyCookie] = []

      public var code: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _body: TypesBytes? = nil
    }

    public struct Regex: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var main: AsyncifyCommand.Sync.Regex.Match {
        get {return _main ?? AsyncifyCommand.Sync.Regex.Match()}
        set {_main = newValue}
      }
      /// Returns true if `main` has been explicitly set.
      public var hasMain: Bool {return self._main != nil}
      /// Clears the value of `main`. Subsequent reads from it will return its default value.
      public mutating func clearMain() {self._main = nil}

      public var groups: Dictionary<Int32,AsyncifyCommand.Sync.Regex.Match> = [:]

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Match: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// start byte index
        public var start: Int32 = 0

        public var end: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _main: AsyncifyCommand.Sync.Regex.Match? = nil
    }

    public struct JavaScript: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var data: AsyncifyCommand.Sync.JavaScript.OneOf_Data? = nil

      public var eval: String {
        get {
          if case .eval(let v)? = data {return v}
          return String()
        }
        set {data = .eval(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Data: Equatable, Sendable {
        case eval(String)

      }

      public init() {}
    }

    public struct FileDescriptor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var status: Int32 = 0

      public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
        get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
        set {_metadata = newValue}
      }
      /// Returns true if `metadata` has been explicitly set.
      public var hasMetadata: Bool {return self._metadata != nil}
      /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
      public mutating func clearMetadata() {self._metadata = nil}

      public var content: TypesBytes {
        get {return _content ?? TypesBytes()}
        set {_content = newValue}
      }
      /// Returns true if `content` has been explicitly set.
      public var hasContent: Bool {return self._content != nil}
      /// Clears the value of `content`. Subsequent reads from it will return its default value.
      public mutating func clearContent() {self._content = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
      fileprivate var _content: TypesBytes? = nil
    }

    public init() {}
  }

  public struct Event: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: AsyncifyCommand.Event.Kind = .error

    public var data: AsyncifyCommand.Event.OneOf_Data? = nil

    public var error: AsyncifyCommand.Event.Error {
      get {
        if case .error(let v)? = data {return v}
        return AsyncifyCommand.Event.Error()
      }
      set {data = .error(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Data: Equatable, Sendable {
      case error(AsyncifyCommand.Event.Error)

    }

    public enum Kind: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case error // = 0
      case UNRECOGNIZED(Int)

      public init() {
        self = .error
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .error
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .error: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [AsyncifyCommand.Event.Kind] = [
        .error,
      ]

    }

    public struct Error: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var code: Int32 = 0

      public var reason: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "asyncify.flows"

extension AsyncifyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "premium"),
    2: .standard(proto: "content_type"),
    3: .standard(proto: "bundle_id"),
    4: .standard(proto: "device_id"),
    5: .standard(proto: "country_code"),
    6: .standard(proto: "language_code"),
    7: .standard(proto: "region_code"),
    8: .standard(proto: "app_version"),
    9: .same(proto: "extra"),
    10: .same(proto: "platform"),
    11: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.premium) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._extra) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.premium != false {
      try visitor.visitSingularBoolField(value: self.premium, fieldNumber: 1)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 2)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 3)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 4)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 5)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 6)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 7)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 8)
    }
    try { if let v = self._extra {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 10)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyOptions, rhs: AsyncifyOptions) -> Bool {
    if lhs.premium != rhs.premium {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs._extra != rhs._extra {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCookie: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cookie"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "path"),
    3: .same(proto: "name"),
    4: .same(proto: "value"),
    5: .same(proto: "secure"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._secure) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    try { if let v = self._secure {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCookie, rhs: AsyncifyCookie) -> Bool {
    if lhs._domain != rhs._domain {return false}
    if lhs._path != rhs._path {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs._secure != rhs._secure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "http"),
    3: .same(proto: "ws"),
    4: .same(proto: "regex"),
    5: .same(proto: "js"),
    6: .same(proto: "fd"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: AsyncifyAction.HTTP?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .http(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .http(v)
        }
      }()
      case 3: try {
        var v: AsyncifyAction.WebSocket?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .ws(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .ws(v)
        }
      }()
      case 4: try {
        var v: AsyncifyAction.Regex?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .regex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .regex(v)
        }
      }()
      case 5: try {
        var v: AsyncifyAction.JavaScript?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .js(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .js(v)
        }
      }()
      case 6: try {
        var v: AsyncifyAction.FileDescriptor?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .fd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .fd(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    switch self.action {
    case .http?: try {
      guard case .http(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ws?: try {
      guard case .ws(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .regex?: try {
      guard case .regex(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .js?: try {
      guard case .js(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fd?: try {
      guard case .fd(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction, rhs: AsyncifyAction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.HTTP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.protoMessageName + ".HTTP"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "headers"),
    3: .same(proto: "method"),
    4: .same(proto: "body"),
    5: .same(proto: "cookies"),
    6: .same(proto: "multiparts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.cookies) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.multiparts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 2)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 3)
    }
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.cookies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cookies, fieldNumber: 5)
    }
    if !self.multiparts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.multiparts, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.HTTP, rhs: AsyncifyAction.HTTP) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.method != rhs.method {return false}
    if lhs._body != rhs._body {return false}
    if lhs.cookies != rhs.cookies {return false}
    if lhs.multiparts != rhs.multiparts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.HTTP.Part: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.HTTP.protoMessageName + ".Part"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "value"),
    3: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.HTTP.Part, rhs: AsyncifyAction.HTTP.Part) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.value != rhs.value {return false}
    if lhs._filename != rhs._filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.WebSocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.protoMessageName + ".WebSocket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "headers"),
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 2)
    }
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.WebSocket, rhs: AsyncifyAction.WebSocket) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.Regex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.protoMessageName + ".Regex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "pattern"),
    3: .same(proto: "groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pattern) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pattern.isEmpty {
      try visitor.visitSingularStringField(value: self.pattern, fieldNumber: 2)
    }
    if !self.groups.isEmpty {
      try visitor.visitPackedInt32Field(value: self.groups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.Regex, rhs: AsyncifyAction.Regex) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.JavaScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.protoMessageName + ".JavaScript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "src"),
    2: .same(proto: "eval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.src) }()
      case 2: try {
        var v: AsyncifyAction.JavaScript.Eval?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .eval(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .eval(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.src.isEmpty {
      try visitor.visitSingularStringField(value: self.src, fieldNumber: 1)
    }
    try { if case .eval(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.JavaScript, rhs: AsyncifyAction.JavaScript) -> Bool {
    if lhs.src != rhs.src {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.JavaScript.Eval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.JavaScript.protoMessageName + ".Eval"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fn"),
    2: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fn) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fn.isEmpty {
      try visitor.visitSingularStringField(value: self.fn, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.JavaScript.Eval, rhs: AsyncifyAction.JavaScript.Eval) -> Bool {
    if lhs.fn != rhs.fn {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.protoMessageName + ".FileDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "write"),
    3: .same(proto: "read"),
    4: .same(proto: "metadata"),
    5: .same(proto: "delete"),
    6: .same(proto: "mkdir"),
    7: .same(proto: "move"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try {
        var v: AsyncifyAction.FileDescriptor.Write?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .write(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .write(v)
        }
      }()
      case 3: try {
        var v: AsyncifyAction.FileDescriptor.Read?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .read(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .read(v)
        }
      }()
      case 4: try {
        var v: AsyncifyAction.FileDescriptor.Metadata?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .metadata(v)
        }
      }()
      case 5: try {
        var v: AsyncifyAction.FileDescriptor.Delete?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delete(v)
        }
      }()
      case 6: try {
        var v: AsyncifyAction.FileDescriptor.Mkdir?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .mkdir(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .mkdir(v)
        }
      }()
      case 7: try {
        var v: AsyncifyAction.FileDescriptor.Move?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .move(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    switch self.action {
    case .write?: try {
      guard case .write(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .read?: try {
      guard case .read(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .metadata?: try {
      guard case .metadata(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .mkdir?: try {
      guard case .mkdir(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .move?: try {
      guard case .move(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor, rhs: AsyncifyAction.FileDescriptor) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor.Write: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.FileDescriptor.protoMessageName + ".Write"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "enc"),
    3: .same(proto: "append"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._enc) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.append) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enc {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.append != false {
      try visitor.visitSingularBoolField(value: self.append, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor.Write, rhs: AsyncifyAction.FileDescriptor.Write) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._enc != rhs._enc {return false}
    if lhs.append != rhs.append {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor.Read: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.FileDescriptor.protoMessageName + ".Read"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._enc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enc {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor.Read, rhs: AsyncifyAction.FileDescriptor.Read) -> Bool {
    if lhs._enc != rhs._enc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.FileDescriptor.protoMessageName + ".Metadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor.Metadata, rhs: AsyncifyAction.FileDescriptor.Metadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.FileDescriptor.protoMessageName + ".Delete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor.Delete, rhs: AsyncifyAction.FileDescriptor.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor.Mkdir: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.FileDescriptor.protoMessageName + ".Mkdir"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor.Mkdir, rhs: AsyncifyAction.FileDescriptor.Mkdir) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyAction.FileDescriptor.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyAction.FileDescriptor.protoMessageName + ".Move"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyAction.FileDescriptor.Move, rhs: AsyncifyAction.FileDescriptor.Move) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyFieldEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyFieldEntry, rhs: AsyncifyFieldEntry) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyFieldEntry.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "TYPE_BOOL"),
    2: .same(proto: "TYPE_INT"),
    3: .same(proto: "TYPE_DOUBLE"),
    4: .same(proto: "TYPE_STRING"),
  ]
}

extension AsyncifyCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .same(proto: "kind"),
    3: .standard(proto: "request_id"),
    4: .same(proto: "call"),
    5: .same(proto: "sync"),
    6: .same(proto: "event"),
    7: .same(proto: "delegate"),
  ]

  fileprivate class _StorageClass {
    var _options: AsyncifyOptions? = nil
    var _kind: AsyncifyCommand.Kind = .call
    var _requestID: String = String()
    var _data: AsyncifyCommand.OneOf_Data?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _options = source._options
      _kind = source._kind
      _requestID = source._requestID
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._options) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 4: try {
          var v: AsyncifyCommand.Call?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .call(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .call(v)
          }
        }()
        case 5: try {
          var v: AsyncifyCommand.Sync?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .sync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .sync(v)
          }
        }()
        case 6: try {
          var v: AsyncifyCommand.Event?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .event(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .event(v)
          }
        }()
        case 7: try {
          var v: AsyncifyAction?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .delegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .delegate(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._kind != .call {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 2)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 3)
      }
      switch _storage._data {
      case .call?: try {
        guard case .call(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .sync?: try {
        guard case .sync(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .event?: try {
        guard case .event(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .delegate?: try {
        guard case .delegate(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand, rhs: AsyncifyCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._options != rhs_storage._options {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALL"),
    1: .same(proto: "SYNC"),
    2: .same(proto: "EVENT"),
    3: .same(proto: "DELEGATE"),
  ]
}

extension AsyncifyCommand.Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.protoMessageName + ".Call"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._args {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Call, rhs: AsyncifyCommand.Call) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._args != rhs._args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.protoMessageName + ".Sync"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "http"),
    2: .same(proto: "ws"),
    3: .same(proto: "regex"),
    4: .same(proto: "js"),
    5: .same(proto: "fd"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: AsyncifyCommand.Sync.HTTP?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .http(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .http(v)
        }
      }()
      case 2: try {
        var v: AsyncifyCommand.Sync.WebSocket?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .ws(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .ws(v)
        }
      }()
      case 3: try {
        var v: AsyncifyCommand.Sync.Regex?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .regex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .regex(v)
        }
      }()
      case 4: try {
        var v: AsyncifyCommand.Sync.JavaScript?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .js(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .js(v)
        }
      }()
      case 5: try {
        var v: AsyncifyCommand.Sync.FileDescriptor?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .fd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .fd(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .http?: try {
      guard case .http(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ws?: try {
      guard case .ws(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .regex?: try {
      guard case .regex(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .js?: try {
      guard case .js(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .fd?: try {
      guard case .fd(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync, rhs: AsyncifyCommand.Sync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync.HTTP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Sync.protoMessageName + ".HTTP"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "headers"),
    3: .same(proto: "cookies"),
    4: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cookies) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 2)
    }
    if !self.cookies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cookies, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync.HTTP, rhs: AsyncifyCommand.Sync.HTTP) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.cookies != rhs.cookies {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync.WebSocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Sync.protoMessageName + ".WebSocket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "headers"),
    3: .same(proto: "cookies"),
    4: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cookies) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 2)
    }
    if !self.cookies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cookies, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync.WebSocket, rhs: AsyncifyCommand.Sync.WebSocket) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.cookies != rhs.cookies {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync.Regex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Sync.protoMessageName + ".Regex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "main"),
    2: .same(proto: "groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._main) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,AsyncifyCommand.Sync.Regex.Match>.self, value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._main {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,AsyncifyCommand.Sync.Regex.Match>.self, value: self.groups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync.Regex, rhs: AsyncifyCommand.Sync.Regex) -> Bool {
    if lhs._main != rhs._main {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync.Regex.Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Sync.Regex.protoMessageName + ".Match"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync.Regex.Match, rhs: AsyncifyCommand.Sync.Regex.Match) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync.JavaScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Sync.protoMessageName + ".JavaScript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .eval(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .eval(let v)? = self.data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync.JavaScript, rhs: AsyncifyCommand.Sync.JavaScript) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Sync.FileDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Sync.protoMessageName + ".FileDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "metadata"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Sync.FileDescriptor, rhs: AsyncifyCommand.Sync.FileDescriptor) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.protoMessageName + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try {
        var v: AsyncifyCommand.Event.Error?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .error {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if case .error(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Event, rhs: AsyncifyCommand.Event) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncifyCommand.Event.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR"),
  ]
}

extension AsyncifyCommand.Event.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AsyncifyCommand.Event.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncifyCommand.Event.Error, rhs: AsyncifyCommand.Event.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
